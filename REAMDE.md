1. アプリケーション概要
本アプリケーションは、学校のSlackワークスペースの過去のメッセージを検索し、質問にAIが対話形式で回答するチャットボットです。
目的: ユーザーが知りたい情報を過去のメッセージ履歴から迅速に探し出すことを可能にし、情報共有の効率化を図ります。
ターゲットユーザー: 学内のSlackワークスペースのメンバー
2. 機能要件
2.1. コア機能
メッセージの取り込み:
指定したSlackチャンネルの過去のメッセージを定期的に取得します。
新規に投稿されたメッセージをリアルタイムで取得します。
質問への応答:
ユーザーがボットをメンションして質問すると、関連性の高い過去のメッセージを検索し、それに基づいて回答を生成します。
回答は対話形式で、簡潔かつ正確な要約を提供します。
関連メッセージの提示:
回答の補足として、回答の根拠となった元のSlackメッセージへのリンク（パーマリンク）を提示します。
2.2. 非機能要件
性能: 質問から回答までの応答時間は最大10秒以内とします。
拡張性: 将来的に、取り込み対象のチャンネルを複数に増やせるように設計します。
プライバシー: 個人のDMや特定のプライベートチャンネルにはアクセスしないように設定します。
3. アプリケーションアーキテクチャ
このシステムは、RAG（Retrieval-Augmented Generation）の原則に基づいて設計します。
!(https://storage.googleapis.com/gcp-community/images/google-ai-slack-bot-architecture.png)
データ取り込みコンポーネント:
Slack APIを使ってメッセージ履歴を取得し、ベクトル化処理に渡します。
Pythonスクリプトとして実装し、cronジョブなどで定期実行をスケジューリングします。
ベクトルデータベース:
取り込まれたメッセージのベクトル（埋め込み）と、元のテキストデータを保存します。
技術: ChromaDBまたはFAISS（ローカルで動作し、費用がかからないため）。
データ構造: (ベクトル, テキスト, メッセージID, チャンネルID)のタプルを保存します。
Slack App（ボット）:
SlackのイベントAPIを購読し、メンションされたメッセージをトリガーとします。
Pythonのslack-boltライブラリを使用して、イベントハンドリングとメッセージ送信を実装します。
推論コンポーネント（LLM）:
ユーザーからの質問を処理し、回答を生成します。
技術: Gemini API (google-genaiライブラリ)を使用します。
処理フロー:
質問文をGeminiのEmbeddingモデルでベクトル化。
ベクトルデータベースで、最も類似度の高いメッセージを検索。
検索結果のテキストと元の質問を組み合わせて、GeminiのLLMにプロンプトとして送信。
LLMが生成した回答をユーザーに返信。
4. 技術スタック
4.1. 言語・ライブラリ
Python 3.10+: 主要な開発言語。
google-genai: Gemini APIとの連携に使用。
slack-sdk または slack-bolt: Slack APIとのやり取りに使用。
ChromaDB: ベクトルデータベースとして使用。
dotenv: 環境変数の管理に使用。
4.2. サービス・プラットフォーム
Google AI Studio: APIキーの発行とモデルのテストに使用。
Slack App: ボットの作成と権限設定に使用。
実行環境:
ローカルPC、または学内のサーバー。
簡易的なデプロイには、Herokuの無料枠やGoogle Cloud Functionsなどのサーバーレス環境も検討。ただし、無料枠の制限に注意。
5. 開発のステップ
Slack Appの作成:
SlackのAppディレクトリで新規アプリを作成し、chat:writeやchannels:historyなどの必要な権限を付与します。
APIキーの取得:
Google AI StudioでGeminiのAPIキーを発行します。
データ取り込みスクリプトの作成:
PythonでSlackからメッセージを取得し、ベクトル化してChromaDBに保存するスクリプトを記述します。
ボットのロジック開発:
slack-boltを使って、ユーザーの質問をトリガーに、GeminiとChromaDBを連携させるロジックを実装します。
テストとデプロイ:
ローカル環境でボットの動作をテストし、問題なければ学内のサーバーなどにデプロイします。